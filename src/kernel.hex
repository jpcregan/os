0x0	; entry

	; stack setup

	; NOTE: A bug exists preventing SS from being set to 0x0 and SP to 0x1000 even though the effective address is the same.
	; This seems related to the SS interrupt issue found on early 8088 revisions, but using the disable interrupt flag as a workaround has no effect.
	; Changing to the 1982 revision in the 86Box emulator solves the issue, but for compatibility reasons SS is set at 0xc0.
	; I will dump both BIOS revisions later to fully understand the issue.

	b8 c0 00	; ax = 0xc0
	8e c8		; ss = ax
	bc 00 04	; sp = 0x400

	; register setup

	b8 00 00	; ax = 0x0
	b9 00 00	; cx = 0x0
	ba 00 00	; dx = 0x0
	bb 00 00	; bx = 0x0
	bd 00 00	; bp = 0x0
	be 00 00	; si = 0x0
	bf 00 00	; di = 0x0

	; segment register setup

	b8 00 00	; ax = 0x0
	8e c0		; es = ax

	b8 00 01	; ax = 0x100
	8e d8		; ds = ax

	; print message

	be 80 00	; si = 0x80
	9a 20 01 00 01	; call print string

	; load shell

	b0 01		; al = 0x1
	9a 00 03 00 01	; call load program

0x80	; message

	"os" 0d 0a

0x100	; print char

	50		; push ax
	53		; push bx

	b4 0e		; ah = 0xe
	b7 00		; bh = 0x0

	cd 10		; int 0x10

	5b		; pop bx
	58		; pop ax

	cb		; return

0x120	; print string

	50		; push ax
	57		; push si

	; loop

	ac		; al = [ds:si++]

	3c 00		; cmp al - 0x0
	74 07		; je end

	9a 00 01 00 01	; call print char
	eb f4		; jmp loop

	; end

	5e		; pop si
	58		; pop ax

	cb		; return

0x140	; print hex 4

	50		; push ax

	24 0f		; and al 0xf

	3c 0a		; cmp al - 0xa
	7c 02		; jl 0x2

	04 27		; al += 0x11

	04 30		; al += 0x30
	9a 00 01 00 01	; call print char

	58		; pop ax

	cb		; return

0x160	; print hex 8

	50		; push ax
	51		; push cx

	b1 04		; cl = 0x4
	d2 e8		; shl al
	9a 40 01 00 01	; call print hex 4

	59		; pop cx
	58		; pop ax

	9a 40 01 00 01	; call print hex 4

	cb		; return

0x180	; print hex 16

	50		; push ax
	51		; push cx

	b1 08		; cl = 0x8
	d3 e8		; shl ax
	9a 60 01 00 01	; call print hex 8

	59		; pop cx
	58		; pop ax

	9a 60 01 00 01	; call print hex 8

	b0 00		; al = 0x0
	9a 00 01 00 01	; call print char

	cb		; return

0x200	; get char

	b4 00		; ah = 0x0
	cd 16		; int 0x16

	cb		; return

0x300	; load program

	; track number in al
	; this function never returns to caller, so we can ignore saving registers

	b2 00		; dl = 0x0 (drive number)
	b6 00		; dh = 0x0 (head number)
	88 c5		; ch = al (track number)
	b1 01		; cl = 0x1 (sector number)
	b0 08		; al = 0x8 (number of sectors)

	bb 00 02	; bx = 0x200
	8e c3		; es = bx
	bb 00 00	; bx = 0x0

	b4 02		; ah = 0x2
	cd 13		; int 0x13

	; setup data segment

	b8 00 02	; ax = 0x200
	8e d8		; ds = ax

	9a 00 00 00 02	; call program

	; reset system

	ea 00 00 00 01	; jump 0x100:0x0

0x400	; print registers

	57 56 55 54 53 52 51 50	; push all registers

	1e		; push ds

	50		; push ax
	b8 00 01	; ax = 0x100
	8e d8		; ds = ax
	58		; pop ax

	be 80 04	; si = 0x480
	9a 20 01 00 01	; call print string

	1f		; pop ds

	58
	9a 80 01 00 01	; call print hex 16

	58
	9a 80 01 00 01	; call print hex 16

	58
	9a 80 01 00 01	; call print hex 16

	58
	9a 80 01 00 01	; call print hex 16

	; newline

	b0 0d		; al = 0xd
	9a 00 01 00 01	; call print char
	b0 0a		; al = 0xa
	9a 00 01 00 01	; call print char

	58
	9a 80 01 00 01	; call print hex 16

	58
	9a 80 01 00 01	; call print hex 16

	58
	9a 80 01 00 01	; call print hex 16

	58
	9a 80 01 00 01	; call print hex 16

	; newline

	b0 0d		; al = 0xd
	9a 00 01 00 01	; call print char
	b0 0a		; al = 0xa
	9a 00 01 00 01	; call print char

	; newline

	b0 0d		; al = 0xd
	9a 00 01 00 01	; call print char
	b0 0a		; al = 0xa
	9a 00 01 00 01	; call print char

	cb		; return

0x480	; register string

	"AX   CX   DX   BX" 0d 0a 
	"SP   BP   SI   DI" 0d 0a
	0d 0a 00

0xd00	; end
